// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package sender

import (
	"sync"
)

// Ensure, that ServerAPIMock does implement ServerAPI.
// If this is not the case, regenerate this file with moq.
var _ ServerAPI = &ServerAPIMock{}

// ServerAPIMock is a mock implementation of ServerAPI.
//
//	func TestSomethingThatUsesServerAPI(t *testing.T) {
//
//		// make and configure a mocked ServerAPI
//		mockedServerAPI := &ServerAPIMock{
//			UpdateCountersFunc: func(counters map[string]int64) error {
//				panic("mock out the UpdateCounters method")
//			},
//			UpdateGaugesFunc: func(gauges map[string]float64) error {
//				panic("mock out the UpdateGauges method")
//			},
//		}
//
//		// use mockedServerAPI in code that requires ServerAPI
//		// and then make assertions.
//
//	}
type ServerAPIMock struct {
	// UpdateCountersFunc mocks the UpdateCounters method.
	UpdateCountersFunc func(counters map[string]int64) error

	// UpdateGaugesFunc mocks the UpdateGauges method.
	UpdateGaugesFunc func(gauges map[string]float64) error

	// calls tracks calls to the methods.
	calls struct {
		// UpdateCounters holds details about calls to the UpdateCounters method.
		UpdateCounters []struct {
			// Counters is the counters argument value.
			Counters map[string]int64
		}
		// UpdateGauges holds details about calls to the UpdateGauges method.
		UpdateGauges []struct {
			// Gauges is the gauges argument value.
			Gauges map[string]float64
		}
	}
	lockUpdateCounters sync.RWMutex
	lockUpdateGauges   sync.RWMutex
}

// UpdateCounters calls UpdateCountersFunc.
func (mock *ServerAPIMock) UpdateCounters(counters map[string]int64) error {
	callInfo := struct {
		Counters map[string]int64
	}{
		Counters: counters,
	}
	mock.lockUpdateCounters.Lock()
	mock.calls.UpdateCounters = append(mock.calls.UpdateCounters, callInfo)
	mock.lockUpdateCounters.Unlock()
	if mock.UpdateCountersFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.UpdateCountersFunc(counters)
}

// UpdateCountersCalls gets all the calls that were made to UpdateCounters.
// Check the length with:
//
//	len(mockedServerAPI.UpdateCountersCalls())
func (mock *ServerAPIMock) UpdateCountersCalls() []struct {
	Counters map[string]int64
} {
	var calls []struct {
		Counters map[string]int64
	}
	mock.lockUpdateCounters.RLock()
	calls = mock.calls.UpdateCounters
	mock.lockUpdateCounters.RUnlock()
	return calls
}

// UpdateGauges calls UpdateGaugesFunc.
func (mock *ServerAPIMock) UpdateGauges(gauges map[string]float64) error {
	callInfo := struct {
		Gauges map[string]float64
	}{
		Gauges: gauges,
	}
	mock.lockUpdateGauges.Lock()
	mock.calls.UpdateGauges = append(mock.calls.UpdateGauges, callInfo)
	mock.lockUpdateGauges.Unlock()
	if mock.UpdateGaugesFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.UpdateGaugesFunc(gauges)
}

// UpdateGaugesCalls gets all the calls that were made to UpdateGauges.
// Check the length with:
//
//	len(mockedServerAPI.UpdateGaugesCalls())
func (mock *ServerAPIMock) UpdateGaugesCalls() []struct {
	Gauges map[string]float64
} {
	var calls []struct {
		Gauges map[string]float64
	}
	mock.lockUpdateGauges.RLock()
	calls = mock.calls.UpdateGauges
	mock.lockUpdateGauges.RUnlock()
	return calls
}
