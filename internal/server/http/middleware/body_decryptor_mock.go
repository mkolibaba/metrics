// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package middleware

import (
	"sync"
)

// Ensure, that BodyDecryptorMock does implement BodyDecryptor.
// If this is not the case, regenerate this file with moq.
var _ BodyDecryptor = &BodyDecryptorMock{}

// BodyDecryptorMock is a mock implementation of BodyDecryptor.
//
//	func TestSomethingThatUsesBodyDecryptor(t *testing.T) {
//
//		// make and configure a mocked BodyDecryptor
//		mockedBodyDecryptor := &BodyDecryptorMock{
//			DecryptFunc: func(bytes []byte) ([]byte, error) {
//				panic("mock out the Decrypt method")
//			},
//		}
//
//		// use mockedBodyDecryptor in code that requires BodyDecryptor
//		// and then make assertions.
//
//	}
type BodyDecryptorMock struct {
	// DecryptFunc mocks the Decrypt method.
	DecryptFunc func(bytes []byte) ([]byte, error)

	// calls tracks calls to the methods.
	calls struct {
		// Decrypt holds details about calls to the Decrypt method.
		Decrypt []struct {
			// Bytes is the bytes argument value.
			Bytes []byte
		}
	}
	lockDecrypt sync.RWMutex
}

// Decrypt calls DecryptFunc.
func (mock *BodyDecryptorMock) Decrypt(bytes []byte) ([]byte, error) {
	callInfo := struct {
		Bytes []byte
	}{
		Bytes: bytes,
	}
	mock.lockDecrypt.Lock()
	mock.calls.Decrypt = append(mock.calls.Decrypt, callInfo)
	mock.lockDecrypt.Unlock()
	if mock.DecryptFunc == nil {
		var (
			bytesOut []byte
			errOut   error
		)
		return bytesOut, errOut
	}
	return mock.DecryptFunc(bytes)
}

// DecryptCalls gets all the calls that were made to Decrypt.
// Check the length with:
//
//	len(mockedBodyDecryptor.DecryptCalls())
func (mock *BodyDecryptorMock) DecryptCalls() []struct {
	Bytes []byte
} {
	var calls []struct {
		Bytes []byte
	}
	mock.lockDecrypt.RLock()
	calls = mock.calls.Decrypt
	mock.lockDecrypt.RUnlock()
	return calls
}
